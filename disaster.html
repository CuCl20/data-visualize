<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>disaster visualize</title>
  <script src="libs/d3.v7.js"></script>
  <script src="https://d3js.org/d3-zoom.v2.min.js"></script>
</head>


<body>
    <label for="customTime">输入自定义时间：</label>
    <input type="datetime-local" id="customTime" step="1">
    <button onclick="updateMapAndTracksCustom()">开始</button>
    <span id="currentTime"></span>
    <script>
        
        // 创建 SVG 容器
        var svg = d3.select("body").append("svg")
            .attr("width", 800)
            .attr("height", 600);
        // 设置地理投影
        var projection = d3.geoMercator()
            .scale(250)  // 调整缩放值
            .center([90, 40])  // 调整中心点坐标
            .translate([400, 300]);

        var zoomHandler = d3.zoom()
            .scaleExtent([1, 8])  // 设置缩放范围
            .translateExtent([[0, 0], [800, 600]])  // 设置平移范围
            .on("zoom", zoomed);

        // 应用缩放行为到容器元素
        svg.call(zoomHandler);
        // 创建路径生成器
        var path = d3.geoPath().projection(projection);
        
        var customTimeInput = document.getElementById("customTime");
        var currentTimeDisplay = document.getElementById("currentTime");
        var mapData;
        var typhoonData;
        var today = new Date();
        var formattedToday = today.toISOString().slice(0, 16);
        customTimeInput.value = formattedToday;
        // 加载 GeoJSON 数据
        d3.json('output.geojson').then(function(data) { // 将 'data' 重命名为 'mapData'
            mapData=data
            svg.selectAll('path')
                .data(mapData.features)
                .enter().append('path')
                .attr('d', path)
                .style('fill', 'steelblue')
                .style('stroke', 'white');

            d3.csv('typhoon.csv').then(function (csvData) {
                var timeParser = d3.timeParse("%Y-%m-%dT%H:%M:%S");
                typhoonData = csvData.map(function(d) {
                    d.台风起始时间 = timeParser(d.台风起始时间);
                    d.台风结束时间 = timeParser(d.台风结束时间);
                    d.当前台风时间 = timeParser(d.当前台风时间);
                    return d;
                });

                // 更新地图和台风轨迹
                updateMapAndTracksCustom();

            });
        }).catch(function(error) {
            console.error('Error loading GeoJSON:', error);
        });

        function updateMapAndTracksCustom() {
            var customTime = new Date(customTimeInput.value);
            if (!isNaN(customTime.getTime())) {
                updateMapAndTracks(customTime);
            } else {
                alert("无效的日期/时间格式。请输入有效的日期和时间。");
            }
        }

        function updateMapAndTracks(currentTimeIndex) {
            // 更新显示当前时间
            currentTimeDisplay.textContent = "自定义时间：" + currentTimeIndex.toISOString();

            // 根据当前时间过滤台风数据
            var filteredTyphoonData = typhoonData.filter(function(d) {
                return d.台风起始时间 <= currentTimeIndex && d.台风结束时间 >= currentTimeIndex;
            });

            // 绘制地图
            svg.selectAll('path')
                .data(mapData.features)
                .attr('d', path);

            // 绘制台风轨迹
            var typhoonPoints = filteredTyphoonData.map(function (d) {
                return {
                    id: d.台风编号,
                    coordinates: [parseFloat(d.经度), parseFloat(d.纬度)]
                };
            });

            svg.selectAll('circle').remove();
            svg.selectAll('line').remove();

            svg.selectAll('circle')
                .data(typhoonPoints)
                .enter().append('circle')
                .attr('cx', function (d) { return projection(d.coordinates)[0]; })
                .attr('cy', function (d) { return projection(d.coordinates)[1]; })
                .attr('r', 1)
                .style('fill', 'red');

            svg.selectAll('line')
                .data(d3.pairs(typhoonPoints))
                .enter().append('line')
                .attr('x1', function(d) {
                    if (d[0].id === d[1].id) {
                        return projection(d[0].coordinates)[0];
                    }
                })
                .attr('y1', function(d) {
                    if (d[0].id === d[1].id) {
                        return projection(d[0].coordinates)[1];
                    }
                })
                .attr('x2', function(d) {
                    if (d[0].id === d[1].id) {
                        return projection(d[1].coordinates)[0];
                    }
                })
                .attr('y2', function(d) {
                    if (d[0].id === d[1].id) {
                        return projection(d[1].coordinates)[1];
                    }
                })
                .style('stroke', 'blue');
        }

        function zoomed(event) {
            svg.selectAll('path')
                .attr('transform', event.transform);

                svg.selectAll('circle')
            .attr('cx', function (d) { return event.transform.apply(projection(d.coordinates))[0]; })
            .attr('cy', function (d) { return event.transform.apply(projection(d.coordinates))[1]; });

        // 更新连接线的位置，包括平移和缩放
        svg.selectAll('line')
            .attr('x1', function(d) {
                if (d[0].id === d[1].id) {
                    return event.transform.apply(projection(d[0].coordinates))[0];
                }
            })
            .attr('y1', function(d) {
                if (d[0].id === d[1].id) {
                    return event.transform.apply(projection(d[0].coordinates))[1];
                }
            })
            .attr('x2', function(d) {
                if (d[0].id === d[1].id) {
                    return event.transform.apply(projection(d[1].coordinates))[0];
                }
            })
            .attr('y2', function(d) {
                if (d[0].id === d[1].id) {
                    return event.transform.apply(projection(d[1].coordinates))[1];
                }
            });
        }

    </script>
</body>